import MdxLayout from "@components/layout/mdx-layout";

export const metadata = {
  title: "NgRx Signal Store: best practices con Angular Signals",
  date: "2025-12-11",
  description:
    "Gu√≠a pr√°ctica de Signal Store (NgRx) para Angular Signals: state at√≥mico, computed peque√±os y cu√°ndo mantener el estado en el componente.",
  category: "NgRx",
  publishDate: "2025-12-11",
  openGraph: {
    title: "NgRx Signal Store: best practices con Angular Signals",
    description:
      "Gu√≠a pr√°ctica de Signal Store (NgRx) para Angular Signals: state at√≥mico, computed peque√±os y cu√°ndo mantener el estado en el componente.",
    type: "article",
    locale: "es_ES",
    url: "https://www.rjvelazco.com/blog/posts/ngrx-signal-store-best-practices-para-un-state-mas-simple-y-eficiente/",
    siteName: "Rafael Velazco",
    images: [
      {
        url: "/assets/ngrx-signal-store.png",
        alt: "NgRx Signal Store (Angular Signals) - best practices",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "NgRx Signal Store: best practices con Angular Signals",
    description:
      "Gu√≠a pr√°ctica de Signal Store (NgRx) para Angular Signals: state at√≥mico, computed peque√±os y cu√°ndo mantener el estado en el componente.",
    creator: "@rjvelazco21",
    images: ["/assets/ngrx-signal-store.png"],
  },
  alternates: {
    canonical:
      "https://www.rjvelazco.com/blog/posts/ngrx-signal-store-best-practices-para-un-state-mas-simple-y-eficiente/",
  },
};

export default function Layout({ children }) {
  return (
    <MdxLayout metadata={metadata} image={"/assets/ngrx-signal-store.png"}>
      {children}
    </MdxLayout>
  );
}

# **Tabla de contenido**

1. [**Introducci√≥n**](#introduccion)
2. [**Mant√©n el state at√≥mico**](#mantener-el-state-atomico)
   - [C√≥mo simplificar el state con computed signals](#como-simplificar-el-state-con-computed-signals)
3. [**Evita los mega-computed dividiendo tus dependencias**](#evita-los-mega-computed-dividiendo-tus-dependencias)
   - [Define correctamente tus computeds](#define-correctamente-tus-computeds)
4. [**Si un valor es del component, debe vivir en el component**](#si-un-valor-es-del-component-debe-vivir-en-el-component)
5. [**Conclusi√≥n**](#conclusion)

<a id="introduccion"></a># **NgRx Signal Store Best Practices para un state m√°s simple y eficiente**

Signal Store es una soluci√≥n moderna de [**state management**](https://ngrx.io/guide/store) creada por el equipo de NgRx para trabajar con [**Angular Signals**](https://angular.dev/guide/signals). Aunque no es obligatoria para usar Signals, s√≠ es una de las opciones m√°s recomendadas por su dise√±o reactivo, escalabilidad y consistencia con la [**arquitectura Reactiva de Angular**](https://angular.dev/guide/signals#reactivity-in-angular).

Uno de los problemas m√°s comunes al adoptarlo es que muchos developers terminan sobre-complicando sus **store methods**, su **state**, y sus [**computed signals**](https://angular.dev/guide/signals#computed), ya sea por:

- una **mala definici√≥n del estado**, o
- una **extracci√≥n prematura** de l√≥gica que no pertenece al store.

Para ayudarte a evitar estos anti-patterns, aqu√≠ tienes una serie de tips pr√°cticos aplicables tanto a Signal Store como a cualquier soluci√≥n de state management moderna.

<a id="mantener-el-state-atomico"></a>
## **‚öõÔ∏è Mant√©n el state at√≥mico**

El **state** debe ser lo m√°s **at√≥mico** posible: solo datos ‚Äúcrudos‚Äù, sin c√°lculos, sin informaci√≥n compuesta.

> Una propiedad es at√≥mica cuando no depende de otras propiedades para definirse.

Al almacenar solo datos base en el store, simplificamos las actualizaciones y evita inconsistencias.

Entendamos este concepto desde el **error**. Miremos el siguiente ejemplo:

```tsx
// ‚ùå Algunas propiedades de este state no son propiedades at√≥micas
const initialState: CartState = {
  items: [],
  couponCode: "",
  shippingMethod: "",
  isCheckingOut: false,
  subtotal: 0,
  discount: 0,
  shippingCost: 0,
  total: 0,
};

const store = signalStore(
  withState<CartState>(initialState),
  withMethods(() => {
    return {
      addItemsToCart: (items: CartItem[]) => {
        const newItems = [...store.items(), ...items];

        const subtotal = calculateSubtotal(items);
        const discount = calculateDiscount(subtotal, store.couponCode());
        const shippingCost = calculateShippingCost(items, store.shippingMethod());
        const total = calculateTotalCost({ subtotal, shippingCost, discount });

        patchState(store, {
          items: newItems,
          subtotal,
          discount,
          shippingCost,
          total,
        });
      },
      deleteItemsInCart: () => {
        /* Your function */
      },
    };
  }),
);
```

¬øPudiste notar el error en este state?

üëâüèª Las propiedades `subtotal`, `shippingCost`, `discount` y `total` son **derivables**, porque dependen directamente de otras. Por lo que cada vez que actualicemos una propiedad at√≥mica como: `items`, `couponCode` y `shippingMethod` , debemos estar atentos de actualizar las propiedades derivadas.

<a id="como-simplificar-el-state-con-computed-signals"></a>
### **‚úÖ C√≥mo simplificar el state con computed signals**

Las propiedades derivadas deben implementarse como [**`computed`**](https://angular.dev/guide/signals#computed) dentro del store.

Esto se hace a trav√©s de [**`withComputed`**](https://ngrx.io/guide/signals/computed), que permite definir l√≥gica derivada reactiva basada en Signals.

```tsx
const store = signalStore(
  withState<CartState>(initialState),
  withComputed((store) => {
    const subtotal = computed(() => calculateSubtotal(store.items()));
    const discount = computed(() => calculateDiscount(subtotal(), store.couponCode()));
    const shippingCost = computed(() =>
      calculateShippingCost(store.items(), store.shippingMethod()),
    );
    const total = computed(() => calculateTotalCost({ subtotal, shippingCost, discount }));
    return {
      subtotal,
      discount,
      shippingCost,
      total,
    };
  }),
  withMethods((store) => ({
    addItemsToCart: (items: CartItem[]) => {
      patchState(store, { items: [...store.items(), ...items] });
    },
  })),
);
```

Aqu√≠ utilizamos:

- [**`patchState`**](https://ngrx.io/guide/signals/state#patching-state-values) para actualizar el state principal
- **`computed`** para generar valores derivados que se actualizan autom√°ticamente.

üí° Esto es incre√≠ble por ahora cada computed se va a actualizar de forma autom√°tica cuando sus dependencias se actualicen.

<a id="evita-los-mega-computed-dividiendo-tus-dependencias"></a>
## **‚ö†Ô∏è Evita los mega-computed dividiendo tus dependencias**

Un error frecuente es construir **un solo computed que devuelve un ViewModel completo**, mezclando demasiadas responsabilidades.

Esto impacta:

- Rendimiento.
- Mantenibilidad.
- Claridad del store.

Miremos un ejemplo problem√°tico:

```tsx
cartViewModel: computed<CartViewModel>(() => {
  const items = store.items();
  const couponCode = store.couponCode();
  const shippingMethod = store.shippingMethod();
  const isCheckingOut = store.isCheckingOut();

  const subtotal = calculateSubtotal(...);
  const discount = calculateDiscount(...);
  const shippingCost = calculateShippingCost(...);
  const total = calculateTotal(...);
  const ctaLabel = defineCtaLabel(...);

  return { items, itemsCount, subtotal, discount, shippingCost, total, ctaLabel };
});

```

Este `computed` se recalcula ante **cualquier cambio en cualquiera de sus dependencias**, aunque solo una parte lo necesite.

<aside>
üí°

Por ejemplo:

Si cambia `shippingMethod`, solo deber√≠amos recalcular `shippingCost` y `total`. Pero, debido a c√≥mo est√° definido el `computed`, **todas las propiedades se vuelven a calcular cada vez** üòµ

</aside>

<a id="define-correctamente-tus-computeds"></a>
### **‚úÖ Define correctamente tus computeds**

Seg√∫n la documentaci√≥n de Angular y NgRx, un buen `computed` debe:

- Depender solo de lo necesario.
- Tener un prop√≥sito √∫nico.
- Mantenerse peque√±o y derivable.
- **No mezclar l√≥gica de UI** con l√≥gica de negocio.

Tomando en cuenta el ejemplo anterior, podemos reescribirlo de esta forma:

```tsx
export const cartStore = signalStore(
  withState<CartState>(initialState),
  withComputed((store) => ({
    $subtotal: computed(() => calculateSubtotal(store.items())),
    $discount: computed(() => calculateDiscount(store.$subtotal(), store.couponCode())),
    $shippingCost: computed(() => calculateShippingCost(store.items(), store.shippingMethod())),
    $total: computed(() => store.$subtotal() - store.$discount() + store.$shippingCost()),
  })),
);
```

> Estos `computed` funcionan como **Selectors basados en Signals**, lo cual se alinea con el dise√±o oficial de NgRx Signals.

Aqu√≠ cada `computed` solo se re-calcular√° √∫nicamente si sus dependencias cambian ‚ú®.

<a id="si-un-valor-es-del-component-debe-vivir-en-el-component"></a>
## **üéØ Si un valor es del component, debe vivir en el component**

El objetivo de **Signal Store** no es reemplazar el estado local, sino complementar la arquitectura.

Angular recomienda que los componentes manejen su propio estado local mediante [**`computed`**](https://angular.dev/guide/signals#computed), [**`signal`**](https://angular.dev/guide/signals#signal) y [**dependency injection**](https://angular.dev/guide/dependency-injection).

Miremos este ejemplo de ‚Äú**sobre carga al store**‚Äù

```tsx
const store = signalStore(
  withState<CartState>(initialState),
  withComputeds(() => ({
    // üëáüèª Una propiedad que solo se utilizar√° en un componente
    ctaLabel: computed(() => {
      if (store.isCheckingOut()) return "Processing...";
      return "Checkout now";
    }),
  })),
);
```

Este valor **solo sirve para un bot√≥n**, no es dominio global y ni va a ser compartido en m√∫ltiples lugares ‚Üí debe moverse al componente.

Ejemplo correcto aplicado a un component ser√≠a:

```tsx
@Component({
  selector: "app-cart-checkout-button",
  standalone: true,
  template: `
    <button [disabled]="$itemsCount() === 0 || $ctaLabel() === 'Processing...'">
      {{ $ctaLabel() }}
    </button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CartCheckoutButtonComponent {
  private readonly store = inject(cartStore);

  readonly $ctaLabel = computed(() => {
    const itemsCount = this.store.itemsCount();
    const isCheckingOut = this.store.isCheckingOut();

    if (itemsCount === 0) return "Add products";
    if (isCheckingOut) return "Processing...";

    return "Checkout now";
  });
}
```

Esto respeta las recomendaciones de:

- [**Standalone Components**](https://angular.dev/guide/components)
- [**Local component state con Signals**](https://angular.dev/guide/signals#using-signals-in-components)
- **Principio de responsabilidad √∫nica**

<a id="conclusion"></a>
## **Conclusi√≥n**

Trabajar con Signal Store es mucho m√°s sencillo cuando mantienes el **state** limpio y solo dejas all√≠ lo esencial. Las propiedades derivadas van en **computed**, y las que se usan √∫nicamente en un **component** deben vivir en ese component.

Este enfoque sigue las recomendaciones oficiales de:

- Angular Signals
- NgRx Signal Store
- Arquitecturas reactivas modernas

Con esto tu aplicaci√≥n se vuelve m√°s clara, m√°s ligera y m√°s f√°cil de mantener.
