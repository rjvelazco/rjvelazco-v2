import MdxLayout from '@components/layout/mdx-layout';

export const metadata = {
  title: 'Linked Signals: estado sincronizado sin computeds ni effects',
  date: '2025-12-28',
  description:
    'Aprende a usar linkedSignal en Angular para mantener estado sincronizado con una fuente reactiva, sin depender de computeds mal usados ni effects para state.',
  category: 'Angular',
  publishDate: '2025-12-28',
  openGraph: {
    title: 'Linked Signals: estado sincronizado sin computeds ni effects',
    description:
      'Aprende a usar linkedSignal en Angular para mantener estado sincronizado con una fuente reactiva, sin depender de computeds mal usados ni effects para state.',
    type: 'article',
    locale: 'es_ES',
    url: 'https://www.rjvelazco.com/blog/posts/linked-signal-estado-sincronizado-sin-computadas-ni-efectos/',
    siteName: 'Rafael Velazco',
    images: [
      {
        url: '/assets/angular-banner.webp',
        alt: 'Angular linkedSignal - estado sincronizado sin computeds ni effects',
      },
    ],
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Linked Signals: estado sincronizado sin computeds ni effects',
    description:
      'Aprende a usar linkedSignal en Angular para mantener estado sincronizado con una fuente reactiva, sin depender de computeds mal usados ni effects para state.',
    creator: '@rjvelazco21',
    images: ['/assets/angular-banner.webp'],
  },
  alternates: {
    canonical: 'https://www.rjvelazco.com/blog/posts/linked-signal-estado-sincronizado-sin-computadas-ni-efectos/',
  },
};

export default function Layout({ children }) {
  return <MdxLayout metadata={metadata}>{children}</MdxLayout>;
}

La forma m√°s sencilla de explicar un **Linked Signal** es pensar en √©l como un **writable computed**.

Se comporta como un `computed`, pero con una diferencia clave:
üëâ **puedes setear su valor manualmente**, y al mismo tiempo mantenerlo sincronizado con una fuente reactiva.

Es uno de esos conceptos que se entienden mucho mejor con ejemplos, as√≠ que veamos dos casos muy comunes:

- reemplazar un `computed` mal usado por un `linkedSignal`
- reemplazar un `effect` usado para manejar state

Antes de ver los ejemplos, expliquemos r√°pidamente c√≥mo usar `linkedSignal`.

## **C√≥mo usar `linkedSignal` en pocas palabras**

Antes de ver los ejemplos, vale la pena saber que `linkedSignal` se puede usar **de dos formas**.

### **1. Forma simple**

Ideal cuando solo necesitas derivar un valor reactivo y mantenerlo sincronizado:

```ts
const isUserOnline = linkedSignal(() => user().status === 'online');
```

### **2. Forma extendida**

√ötil cuando necesitas m√°s control o acceder al valor anterior:

```ts
const activeOption = linkedSignal({
  source: optionsSignal,
  computation: (newOptions, previous) => newOptions.find((opt) => opt.id === previous?.value.id) ?? newOptions[0],
});
```

Ambas formas crean un estado **reactivo y writable**, sincronizado autom√°ticamente con su fuente.

Si quieres profundizar en el API completo, la documentaci√≥n oficial lo explica en detalle:
üëâ [https://angular.dev/api/core/linkedSignal](https://angular.dev/api/core/linkedSignal)

## **Computed no siempre es la mejor opci√≥n**

Imaginemos el siguiente componente:

> üìö Un selector de libros donde el usuario puede elegir uno,
> pero por l√≥gica de negocio **siempre hay un libro seleccionado por defecto**.

### ‚ùå Mala pr√°ctica: usar `computed` para manejar selecci√≥n

```tsx
export class BookSelectorComponent {
  books = input.required<Book[]>();
  userSelectedBook = signal<Book | null>(null);

  selectedBook = computed(() => this.userSelectedBook() ?? this.books()[0]);

  onSelectBook(book: Book) {
    this.userSelectedBook.set(book);
  }
}
```

A simple vista parece correcto, pero tiene varios problemas.

#### Problemas con este approach

‚ùå **Complejidad innecesaria**: Tenemos m√°s propiedades de las que realmente necesitamos para un component simple.

‚ö†Ô∏è **Glitches potenciales**:
¬øQu√© pasa si el `books` input cambia y el libro que el usuario hab√≠a seleccionado ya no existe?

Ahora necesitas:

- un `effect`
- l√≥gica extra
- m√°s c√≥digo solo para mantener consistencia

Todo eso es una se√±al clara de que el modelado del state no es el correcto.

---

## ‚úÖ Buena pr√°ctica: usar Linked Signals para sincronizar state

En lugar de tener m√∫ltiples Signals para decidir cu√°l es el libro seleccionado, podemos usar un **Linked Signal** para mantener ese estado sincronizado con el input.

```tsx
export class BookSelectorComponent {
  books = input.required<Book[]>();

  selectedBook = linkedSignal(() => this.books()[0]);

  onSelectBook(book: Book) {
    this.selectedBook.set(book);
  }
}
```

### ¬øQu√© ganamos con esto?

‚úÖ **Clean Code**: Menos propiedades, menos ramas l√≥gicas, menos c√≥digo.

‚úÖ **Synchronous State**: Si `books` cambia, `selectedBook` se reinicia autom√°ticamente al nuevo valor por defecto.

‚úÖ **Modelo mental m√°s simple**: `selectedBook` es _el_ estado, no una combinaci√≥n de estados.

## **Cuando un effect es una se√±al de alarma**

Ahora veamos un caso muy com√∫n: una lista con paginaci√≥n.

La regla de negocio es simple:
üëâ **si cambia la lista de libros, la paginaci√≥n debe reiniciarse**.

### ‚ùå Mala pr√°ctica: usar `effect` para manejar state

```tsx
export class BookListComponent {
  books = input.required<Book[]>();
  currentPage = signal(1);

  constructor() {
    effect(() => {
      this.books(); // creamos dependencia
      untrack(() => this.currentPage.set(1));
    });
  }

  nextPage() {
    this.currentPage.update((p) => p + 1);
  }

  previousPage() {
    this.currentPage.update((p) => p - 1);
  }
}
```

#### Problemas con este approach

‚ùå **Mal uso de `effect`**:
El propio equipo de Angular recomienda usar effects solo para **side effects** como API calls, logging o integraciones externas, no para manejar state.

‚ùå **Sobrecomplejidad**:
`untrack`, dependencias manuales y mayor riesgo de loops infinitos.

‚ö†Ô∏è **Glitches**:
Los effects no son sincr√≥nicos y pueden generar estados intermedios inconsistentes.

## ‚úÖ Buena pr√°ctica: Linked Signals para state reactivo

Con `linkedSignal`, el mismo caso se vuelve mucho m√°s claro:

```tsx
export class BookListComponent {
  books = input.required<Book[]>();

  currentPage = linkedSignal({
    source: this.books,
    computation: () => 1,
  });

  nextPage() {
    this.currentPage.update((p) => p + 1);
  }

  previousPage() {
    this.currentPage.update((p) => p - 1);
  }
}
```

### Beneficios claros

‚úÖ **Clean Code**: No hay effects, no hay `untrack`, no hay l√≥gica oculta.

‚úÖ **Synchronous State**: El estado de la paginaci√≥n siempre est√° sincronizado con el input.

‚úÖ **C√≥digo expresivo**: El c√≥digo refleja directamente la regla de negocio.

## **TL;DR**

- Usa **Linked Signals** cuando un state:
  - depende de otra Signal
  - pero tambi√©n debe poder actualizarse manualmente

- Evita usar `computed` para estados que el usuario puede modificar
- Evita usar `effect` para manejar state
- Si necesitas sincronizar estado, **Linked Signals suelen ser la mejor opci√≥n**

Linked Signals te permiten modelar el state **como realmente funciona**, sin hacks y sin sobreingenier√≠a.
